Environment Variables(환경변수){
    어느 환경에 배포하느냐에 따라서 다르게 설정해야하는 항목은
    보통 운영 체제 레벨에서 환경 변수를 통해 관리
    ex) DB passward or API key 등..

    process.env라는 object로 접근 가능 import없는 전역개체이므로 어디서나 접근가능
}

prisma, movies, instaclone database 삭제
프로젝트 시작..

User{
    User 정보 스키마 및 queries, typeDefs, mutations 작성

    create account() mutation에서
    중복 username 및 email을 client.user.findFirst로 검색시
    바로 적용되는 것이 아닌 promise를 return 하기 때문에
    async - await 사용을 통해서 기다려준다.

    client object들은 OR: AND: NOT: 같은 filter들을 사용 가능
    ex) findFirst({where:{
            OR:[
                {username}
                {email}
            ]}
        });

    password 관리하기{
        hashing pakage
        bCrypt -> npm i bCrypt
        되도록이면 async & await과 함께 사용

        Hash password and store in DB{
            bcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash))
        }
        Check password{
            bcrypt.compare(myPlaintextPassword, hash, function(err, result) {
            // result == true});
            bcrypt.compare(someOtherPlaintextPassword, hash, function(err, result) {
            // result == false});
        }


        hashing을 통해서 DB에 암호화된 비밀번호 저장
        반대로 hash code로 password로 복호화하는 작업은 불가
        
        creation of account process
        ex) 1234 -> hash(1234) -> DB(dafer31dd5322)

        Login Process
        ex) 1234 -> hash(1234) -> if dafer31dd5322 === DB(dafer31dd5322)
        login 성공!

        salt and papper / rainbow table?? 나중에 찾아보기
    }

    login process{
        username을 바탕으로 db에 있는지 확인 후 (아닐시 에러)
        hash.compare(password, hashed password) => boolean
        password 확인 후 (아닐시 에러)
        token 발행

        json webtoken(jwt){
            login시에 sign된 토큰을 user에게 발행해줌
            server에 request시에 token(sign의 진위여부확인)은
            sepecific한 유저라는 것을 인증하고
            db의 정보에 접속가능
            ex) jwt를 활용한 코로나 QR code check in system

            토큰에 사인하기
            jwt.sign(payload(토큰에 넣을 정보들), secretOrPrivateKey)
            옵션으로 expiresIn을 설정하면 일 시간 단위등으로 유효기간 설정가능
        
            
        }
    }

    es6 ... 문법{
        ...([if true return]&& {return 하고 싶은 값})
        나중에 찾아보기
    }

    http headers{
        section of request and response
        by http header user automatically sends token

        token을 http header에 집어넣어서
        schema에서 token을 사용하지 않도록 코딩

        included in general header{
            Status Code,
            Request URL,
            ...
        }

        included in request header{
            Host - host명
            cookies - browser에서 사용
            sessions - every user data in db, keep tracking
                   force logout user by deleting sessions
                   check how many people or devices share accounts
                   need huge DB maintainance -> can use redis(cheap db)
            User-Agent - client 식별가능 정보 ex) OS, browser version...
            ex) User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
                AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81
                Safari/537.36
        
        included in response header{
            Server - server 정보
            Set-Cookie - cookie 원할때
        }
    }

    reduce redundancy{
        efficiency of code
        계속해서 사용되는 문장을 줄여준다.
    }

    Altair GraphQl Client{
        apollo server client로 playground와 다르게
        file upload를 지원해준다.

        서버 DB에는 파일저장 x, only cide
        주로 aws 같은 외부 서버에 저장 후 URL을 return 해주면
        그 url을 서버DB 에 저장
    }
    stream{
        I/O란 Input과 Output의 약자로 입력과 출력, 간단히 줄여서 입출력이라고 한다. 입출력은 컴퓨터 내부 또는 외부의 장치와 프로그램 간의 데이터를 주고받는 것을 말한다.
        자바에서 모든 입출력은 스트림(stream)을 통해 이루어진다.
        데이터를 운반하는데 사용되는 연결통로이다.

         스트림이란 자료(data) 흐름이 물의 흐름과 같다는 의미에서 사용되었다. 물이 한쪽 방향으로만 흐르는 것과 같이 스트림은 단방향 통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.
        입력과 출력을 동시에 수행하려면 입력을 위한 입력 스트림(input stream)과 출력을 위한 출력 스트림(output stream), 모두 2개의 스트림이 필요하다.
        스트림은 먼저 보낸 데이터를 먼저 받게 되어 있으며
        연속적으로 데이터를 주고받는다.

         큐(queue)와 같은 FIFO(First In First Out) 구조로 되어 있다.
        데이터 근원지를 Source, 데이터 종착점을 Sink, 연결한 것을 Stream
        Source - 입력 스트림 - 출력 스트림 - Sink로 연결된다.
        
        createReadStream() // 스트림 읽기
        createWriteStream({path}) // 스트림 쓰기
        pipe 활용하기
        ex) readStream.pipe(writeStream); 간단히 두개를 연결


        }

    암호화{
        rainbow table{
            hashing 해놓은 easy한 암호들 ex) 1234,0000..
            
            Salt{
                very random piece of text
                hashing 할 때 salt를 끼워넣어서 같이 hash
                -> result는 랜덤한 hashed passward

                rainbow table로 부터 보호!
            }
        }

    apollo-server-express{
        express-server - framework contains {lib,middleWare} to make web app
        middleWare로 확장성을 가진다.

        cant use RESTAPI or Socket IO with portal-server(just apollo-server)
        
        apollo-server로는 gql url만 돌려서 schema 만들기, db관련 업무만 수행
        그외에는 express-server를 활용
    }
    
    morgan {
        nodeJS에서 log 관리를 위한 미들웨어
        :easy to manage logs
        :token or usable utilities
        :log management customize

        ! log의 포맷 지정{
        로그의 포맷을 아래와 같이 선택하거나 지정할 수 있습니다.
        app.use(morgan('combined'));

        combined 외에도 다음과 같은 선택 값이 있습니다.
        'combined'
        'tiny'
        'dev'
        'common'

        Format을 직접 아래와 같이 지정할 수도 있습니다.
        :url // url
        :status // 상태 코드
        :req[header] // 요청 헤더
        :res[header] // 응답 헤더
        :response-time // 응답시간
        :method // 요청 방식}
    }
}
